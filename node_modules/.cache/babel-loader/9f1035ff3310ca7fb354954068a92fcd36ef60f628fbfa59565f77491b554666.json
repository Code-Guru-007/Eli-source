{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useMemo } from 'react';\nexport const DOTS = \"&#8230\";\nexport const usePagination = _ref => {\n  _s();\n  let {\n    totalCount,\n    pageSize,\n    siblingCount = 1,\n    currentPage\n  } = _ref;\n  const paginationRange = useMemo(() => {\n    const totalPageCount = Math.ceil(totalCount / pageSize);\n\n    // Pages count is determined as siblingCount + firstPage + lastPage + currentPage + 2*DOTS\n    const totalPageNumbers = siblingCount + 5;\n\n    /*\r\n      Case 1:\r\n      If the number of pages is less than the page numbers we want to show in our\r\n      paginationComponent, we return the range [1..totalPageCount]\r\n    */\n    if (totalPageNumbers >= totalPageCount) {\n      return range(1, totalPageCount);\n    }\n\n    /*\r\n        Calculate left and right sibling index and make sure they are within range 1 and totalPageCount\r\n    */\n    const leftSiblingIndex = Math.max(currentPage - siblingCount, 1);\n    const rightSiblingIndex = Math.min(currentPage + siblingCount, totalPageCount);\n\n    /*\r\n      We do not show dots just when there is just one page number to be inserted between the extremes of sibling and the page limits i.e 1 and totalPageCount. Hence we are using leftSiblingIndex > 2 and rightSiblingIndex < totalPageCount - 2\r\n    */\n    const shouldShowLeftDots = leftSiblingIndex > 2;\n    const shouldShowRightDots = rightSiblingIndex < totalPageCount - 2;\n    const firstPageIndex = 1;\n    const lastPageIndex = totalPageCount;\n\n    /*\r\n        Case 2: No left dots to show, but rights dots to be shown\r\n    */\n    if (!shouldShowLeftDots && shouldShowRightDots) {\n      let leftItemCount = 3 + 2 * siblingCount;\n      let leftRange = range(1, leftItemCount);\n      return [...leftRange, DOTS, totalPageCount];\n    }\n\n    /*\r\n        Case 3: No right dots to show, but left dots to be shown\r\n    */\n    if (shouldShowLeftDots && !shouldShowRightDots) {\n      let rightItemCount = 3 + 2 * siblingCount;\n      let rightRange = range(totalPageCount - rightItemCount + 1, totalPageCount);\n      return [firstPageIndex, DOTS, ...rightRange];\n    }\n\n    /*\r\n        Case 4: Both left and right dots to be shown\r\n    */\n    if (shouldShowLeftDots && shouldShowRightDots) {\n      let middleRange = range(leftSiblingIndex, rightSiblingIndex);\n      return [firstPageIndex, DOTS, ...middleRange, DOTS, lastPageIndex];\n    }\n  }, [totalCount, pageSize, siblingCount, currentPage]);\n  return paginationRange;\n};\n_s(usePagination, \"tLviJI6rwkyze3+kNwkFLwjvB48=\");","map":{"version":3,"names":["useMemo","DOTS","usePagination","_ref","_s","totalCount","pageSize","siblingCount","currentPage","paginationRange","totalPageCount","Math","ceil","totalPageNumbers","range","leftSiblingIndex","max","rightSiblingIndex","min","shouldShowLeftDots","shouldShowRightDots","firstPageIndex","lastPageIndex","leftItemCount","leftRange","rightItemCount","rightRange","middleRange"],"sources":["E:/Eli/Eli source/Eli source/src/hooks/usePagination.js"],"sourcesContent":["import { useMemo } from 'react'\r\n\r\nexport const DOTS = \"&#8230\";\r\n\r\nexport const usePagination = ({\r\n    totalCount,\r\n    pageSize,\r\n    siblingCount = 1,\r\n    currentPage\r\n  }) => {\r\n    const paginationRange = useMemo(() => {\r\n      const totalPageCount = Math.ceil(totalCount / pageSize);\r\n  \r\n      // Pages count is determined as siblingCount + firstPage + lastPage + currentPage + 2*DOTS\r\n      const totalPageNumbers = siblingCount + 5;\r\n  \r\n      /*\r\n        Case 1:\r\n        If the number of pages is less than the page numbers we want to show in our\r\n        paginationComponent, we return the range [1..totalPageCount]\r\n      */\r\n      if (totalPageNumbers >= totalPageCount) {\r\n        return range(1, totalPageCount);\r\n      }\r\n      \r\n      /*\r\n          Calculate left and right sibling index and make sure they are within range 1 and totalPageCount\r\n      */\r\n      const leftSiblingIndex = Math.max(currentPage - siblingCount, 1);\r\n      const rightSiblingIndex = Math.min(\r\n        currentPage + siblingCount,\r\n        totalPageCount\r\n      );\r\n  \r\n      /*\r\n        We do not show dots just when there is just one page number to be inserted between the extremes of sibling and the page limits i.e 1 and totalPageCount. Hence we are using leftSiblingIndex > 2 and rightSiblingIndex < totalPageCount - 2\r\n      */\r\n      const shouldShowLeftDots = leftSiblingIndex > 2;\r\n      const shouldShowRightDots = rightSiblingIndex < totalPageCount - 2;\r\n  \r\n      const firstPageIndex = 1;\r\n      const lastPageIndex = totalPageCount;\r\n  \r\n      /*\r\n          Case 2: No left dots to show, but rights dots to be shown\r\n      */\r\n      if (!shouldShowLeftDots && shouldShowRightDots) {\r\n        let leftItemCount = 3 + 2 * siblingCount;\r\n        let leftRange = range(1, leftItemCount);\r\n  \r\n        return [...leftRange, DOTS, totalPageCount];\r\n      }\r\n  \r\n      /*\r\n          Case 3: No right dots to show, but left dots to be shown\r\n      */\r\n      if (shouldShowLeftDots && !shouldShowRightDots) {\r\n        \r\n        let rightItemCount = 3 + 2 * siblingCount;\r\n        let rightRange = range(\r\n          totalPageCount - rightItemCount + 1,\r\n          totalPageCount\r\n        );\r\n        return [firstPageIndex, DOTS, ...rightRange];\r\n      }\r\n       \r\n      /*\r\n          Case 4: Both left and right dots to be shown\r\n      */\r\n      if (shouldShowLeftDots && shouldShowRightDots) {\r\n        let middleRange = range(leftSiblingIndex, rightSiblingIndex);\r\n        return [firstPageIndex, DOTS, ...middleRange, DOTS, lastPageIndex];\r\n      }\r\n    }, [totalCount, pageSize, siblingCount, currentPage]);\r\n  \r\n    return paginationRange;\r\n  };"],"mappings":";AAAA,SAASA,OAAO,QAAQ,OAAO;AAE/B,OAAO,MAAMC,IAAI,GAAG,QAAQ;AAE5B,OAAO,MAAMC,aAAa,GAAGC,IAAA,IAKrB;EAAAC,EAAA;EAAA,IALsB;IAC1BC,UAAU;IACVC,QAAQ;IACRC,YAAY,GAAG,CAAC;IAChBC;EACF,CAAC,GAAAL,IAAA;EACC,MAAMM,eAAe,GAAGT,OAAO,CAAC,MAAM;IACpC,MAAMU,cAAc,GAAGC,IAAI,CAACC,IAAI,CAACP,UAAU,GAAGC,QAAQ,CAAC;;IAEvD;IACA,MAAMO,gBAAgB,GAAGN,YAAY,GAAG,CAAC;;IAEzC;AACN;AACA;AACA;AACA;IACM,IAAIM,gBAAgB,IAAIH,cAAc,EAAE;MACtC,OAAOI,KAAK,CAAC,CAAC,EAAEJ,cAAc,CAAC;IACjC;;IAEA;AACN;AACA;IACM,MAAMK,gBAAgB,GAAGJ,IAAI,CAACK,GAAG,CAACR,WAAW,GAAGD,YAAY,EAAE,CAAC,CAAC;IAChE,MAAMU,iBAAiB,GAAGN,IAAI,CAACO,GAAG,CAChCV,WAAW,GAAGD,YAAY,EAC1BG,cACF,CAAC;;IAED;AACN;AACA;IACM,MAAMS,kBAAkB,GAAGJ,gBAAgB,GAAG,CAAC;IAC/C,MAAMK,mBAAmB,GAAGH,iBAAiB,GAAGP,cAAc,GAAG,CAAC;IAElE,MAAMW,cAAc,GAAG,CAAC;IACxB,MAAMC,aAAa,GAAGZ,cAAc;;IAEpC;AACN;AACA;IACM,IAAI,CAACS,kBAAkB,IAAIC,mBAAmB,EAAE;MAC9C,IAAIG,aAAa,GAAG,CAAC,GAAG,CAAC,GAAGhB,YAAY;MACxC,IAAIiB,SAAS,GAAGV,KAAK,CAAC,CAAC,EAAES,aAAa,CAAC;MAEvC,OAAO,CAAC,GAAGC,SAAS,EAAEvB,IAAI,EAAES,cAAc,CAAC;IAC7C;;IAEA;AACN;AACA;IACM,IAAIS,kBAAkB,IAAI,CAACC,mBAAmB,EAAE;MAE9C,IAAIK,cAAc,GAAG,CAAC,GAAG,CAAC,GAAGlB,YAAY;MACzC,IAAImB,UAAU,GAAGZ,KAAK,CACpBJ,cAAc,GAAGe,cAAc,GAAG,CAAC,EACnCf,cACF,CAAC;MACD,OAAO,CAACW,cAAc,EAAEpB,IAAI,EAAE,GAAGyB,UAAU,CAAC;IAC9C;;IAEA;AACN;AACA;IACM,IAAIP,kBAAkB,IAAIC,mBAAmB,EAAE;MAC7C,IAAIO,WAAW,GAAGb,KAAK,CAACC,gBAAgB,EAAEE,iBAAiB,CAAC;MAC5D,OAAO,CAACI,cAAc,EAAEpB,IAAI,EAAE,GAAG0B,WAAW,EAAE1B,IAAI,EAAEqB,aAAa,CAAC;IACpE;EACF,CAAC,EAAE,CAACjB,UAAU,EAAEC,QAAQ,EAAEC,YAAY,EAAEC,WAAW,CAAC,CAAC;EAErD,OAAOC,eAAe;AACxB,CAAC;AAACL,EAAA,CAxESF,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}